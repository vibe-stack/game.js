// Game Editor Types

// This file augments the global scope.
// We use `declare global` because this file is a module (due to the imports).


// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code.
// These are also present in forge.env.d.ts but declared here for full context.
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  projectAPI: ProjectAPI;
  configAPI: ConfigAPI;
  scriptAPI: ScriptAPI;
}



interface Vector3 {
  x: number;
  y: number;
  z: number;
}

interface Transform {
  position: Vector3;
  rotation: Vector3;
  scale: Vector3;
}

interface EditorConfig {
  appTitle: string;
  shortcuts: Record<string, string>;
  theme: "light" | "dark" | "system";
  autoSave: boolean;
  autoSaveInterval: number;
  gridSize: number;
  snapToGrid: boolean;
  showGrid: boolean;
  showGizmos: boolean;
  cameraSpeed: number;
  viewportBackground: string;
}

interface SceneEditorConfig {
  showHelperGrid: boolean;
  gridSize: number;
  backgroundColor: string;
  renderType: "solid" | "wireframe" | "normals" | "realistic";
  showLights: boolean;
  showCameras: boolean;
  enableFog: boolean;
  fogColor: string;
  fogNear: number;
  fogFar: number;
}

interface SceneRuntimeConfig {
  backgroundColor: string;
  environment: string;
  shadowsEnabled: boolean;
  shadowType: "basic" | "pcf" | "pcfsoft" | "vsm";
  antialias: boolean;
  physicallyCorrectLights: boolean;
  toneMapping: "none" | "linear" | "reinhard" | "cineon" | "aces";
  exposure: number;
}

// IPC interface types for Electron
// When adding a new context interface, add it to the exposeContexts() function in preload.ts

interface DevServerInfo {
  port?: number;
  url?: string;
}

interface ConfigAPI {
  readConfigFile: (filePath: string) => Promise<any>;
  writeConfigFile: (filePath: string, content: any) => Promise<boolean>;
  installPackages: (
    projectPath: string,
    packageManager: string,
    packages?: string[],
  ) => Promise<{ success: boolean; output: string }>;
  getPackageInfo: (
    projectPath: string,
  ) => Promise<{ hasPackageJson: boolean; suggestedPackageManager: string }>;
}

interface ScriptAPI {
  startWatching: (projectPath: string) => Promise<boolean>;
  stopWatching: (projectPath: string) => Promise<boolean>;
  compileScript: (projectPath: string, scriptPath: string) => Promise<{ success: boolean; outputPath?: string; error?: string }>;
  getCompiledScripts: (projectPath: string) => Promise<Record<string, string>>;
  getCompilationStatus: (projectPath: string) => Promise<{ isWatching: boolean; compiledCount: number; lastCompilation?: Date }>;
  getImportMap: (projectPath: string) => Promise<Record<string, any> | null>;
}

interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<string>;
}

interface ElectronWindow {
  close: () => void;
  minimize: () => void;
  maximize: () => Promise<boolean>;
  isMaximized: () => Promise<boolean>;
}

interface FileSystemItem {
  name: string;
  path: string;
  type: 'file' | 'directory';
  extension?: string;
  size?: number;
  modified?: Date;
}

// Updated ProjectAPI using new architecture types
interface ProjectAPI {
  // Project Management
  loadProjects: () => Promise<any[]>;
  createProject: (
    projectName: string,
    projectPath?: string,
    template?: string,
    description?: string,
    author?: string,
  ) => Promise<any>;
  openProject: (projectPath: string) => Promise<any>;
  saveProject: (project: any) => Promise<void>;
  deleteProject: (projectPath: string) => Promise<void>;
  openProjectFolder: (projectPath: string) => Promise<void>;
  selectProjectDirectory: () => Promise<string | undefined>;

  // Scene Management
  listScenes: (projectPath: string) => Promise<string[]>;
  loadScene: (projectPath: string, sceneName: string) => Promise<any>;
  saveScene: (projectPath: string, sceneName: string, sceneData: any) => Promise<void>;
  createScene: (projectPath: string, sceneName: string, sceneData?: any) => Promise<void>;
  deleteScene: (projectPath: string, sceneName: string) => Promise<void>;
  switchScene: (projectPath: string, sceneName: string) => Promise<void>;

  // Asset Management
  selectAssetFiles: () => Promise<string[]>;
  importAssetFromData: (
    projectPath: string,
    fileName: string,
    fileData: ArrayBuffer,
  ) => Promise<any>;
  importAsset: (
    projectPath: string,
    assetPath: string,
  ) => Promise<any>;
  deleteAsset: (projectPath: string, assetId: string) => Promise<void>;
  getAssets: (projectPath: string) => Promise<any[]>;
  getAssetDataUrl: (
    projectPath: string,
    assetPath: string,
  ) => Promise<string | null>;
  getAssetUrl: (
    projectPath: string,
    assetPath: string,
  ) => Promise<string | null>;
  getAssetServerPort: (projectPath: string) => Promise<number>;

  // File System Operations
  readFile: (filePath: string) => Promise<string>;
  writeFile: (filePath: string, content: string) => Promise<void>;
  fileExists: (filePath: string) => Promise<boolean>;
  listDirectory: (dirPath: string) => Promise<FileSystemItem[]>;
  getFileStats: (filePath: string) => Promise<{ size: number; modified: Date }>;

  // New File System Operations
  createFile: (filePath: string, content?: string) => Promise<void>;
  createDirectory: (dirPath: string) => Promise<void>;
  deleteFile: (filePath: string) => Promise<void>;
  deleteDirectory: (dirPath: string) => Promise<void>;
  renameItem: (oldPath: string, newPath: string) => Promise<void>;

  // Legacy - keeping for backward compatibility
  installPackages: (projectName: string) => Promise<void>;
  startDevServer: (projectName: string) => Promise<DevServerInfo>;
  stopDevServer: (projectName: string) => Promise<void>;
  isDevServerRunning: (projectName: string) => Promise<boolean>;
  getServerInfo: (projectName: string) => Promise<DevServerInfo | undefined>;
  connectToEditor: (projectName: string) => Promise<void>;
  sendPropertyUpdate: (
    projectName: string,
    property: string,
    value: unknown,
    temporary?: boolean,
  ) => Promise<void>;
  getSceneInfo: (projectName: string) => Promise<unknown>;
}