// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Game Editor Types

interface Vector3 {
  x: number;
  y: number;
  z: number;
}

interface Transform {
  position: Vector3;
  rotation: Vector3;
  scale: Vector3;
}

interface GameObjectComponent {
  id: string;
  type: string;
  enabled: boolean;
  properties: Record<string, any>;
}

// Physics Types for Rapier3D Integration

type RigidBodyType = 'dynamic' | 'static' | 'kinematic';

interface RigidBodyComponent {
  id: string;
  type: 'rigidBody';
  enabled: boolean;
  properties: {
    bodyType: RigidBodyType;
    mass?: number;
    linearDamping: number;
    angularDamping: number;
    gravityScale: number;
    canSleep: boolean;
    sleeping: boolean;
    lockTranslations: {
      x: boolean;
      y: boolean;
      z: boolean;
    };
    lockRotations: {
      x: boolean;
      y: boolean;
      z: boolean;
    };
    dominanceGroup: number;
    additionalMassProperties?: {
      mass: number;
      centerOfMass: Vector3;
      principalInertia: Vector3;
      inertiaOrientation: Vector3; // quaternion as Vector3 for simplicity
    };
  };
}

type ColliderShape = 
  | { type: 'box'; halfExtents: Vector3 }
  | { type: 'sphere'; radius: number }
  | { type: 'capsule'; halfHeight: number; radius: number }
  | { type: 'cylinder'; height: number; radius: number }
  | { type: 'cone'; height: number; radius: number }
  | { type: 'convexHull'; vertices: Vector3[] }
  | { type: 'trimesh'; vertices: Vector3[]; indices: number[] }
  | { type: 'heightfield'; heights: number[][]; scale: Vector3 };

interface PhysicsMaterial {
  friction: number;
  restitution: number;
  frictionCombineRule: 'average' | 'min' | 'multiply' | 'max';
  restitutionCombineRule: 'average' | 'min' | 'multiply' | 'max';
}

interface CollisionGroups {
  membership: number; // Bitmask for which groups this collider belongs to
  filter: number; // Bitmask for which groups this collider can collide with
}

interface ColliderComponent {
  id: string;
  type: 'collider';
  enabled: boolean;
  properties: {
    shape: ColliderShape;
    isSensor: boolean;
    density?: number;
    material: PhysicsMaterial;
    collisionGroups: CollisionGroups;
    solverGroups: CollisionGroups;
    activeCollisionTypes: {
      default: boolean;
      kinematic: boolean;
      sensor: boolean;
    };
    activeEvents: {
      collisionEvents: boolean;
      contactForceEvents: boolean;
    };
    contactForceEventThreshold: number;
    massModification: 'density' | 'mass' | 'massProps';
  };
}

type JointType = 
  | 'fixed'
  | 'revolute' 
  | 'prismatic'
  | 'spherical'
  | 'rope'
  | 'spring'
  | 'generic';

interface JointLimits {
  min: number;
  max: number;
}

interface JointMotor {
  targetVel: number;
  targetPos: number;
  stiffness: number;
  damping: number;
  maxForce: number;
}

interface JointComponent {
  id: string;
  type: 'joint';
  enabled: boolean;
  properties: {
    jointType: JointType;
    connectedBody: string; // ID of the connected GameObject
    anchor1: Vector3; // Local anchor point on this body
    anchor2: Vector3; // Local anchor point on connected body
    axis1?: Vector3; // Primary axis for revolute/prismatic joints
    axis2?: Vector3; // Secondary axis for some joint types
    limits?: JointLimits;
    motor?: JointMotor;
    breakForce?: number; // Force threshold to break the joint
    breakTorque?: number; // Torque threshold to break the joint
    // Generic joint specific properties
    lockedAxes?: {
      linearX: boolean;
      linearY: boolean;
      linearZ: boolean;
      angularX: boolean;
      angularY: boolean;
      angularZ: boolean;
    };
    motorAxes?: {
      linearX: JointMotor;
      linearY: JointMotor;
      linearZ: JointMotor;
      angularX: JointMotor;
      angularY: JointMotor;
      angularZ: JointMotor;
    };
  };
}

type PhysicsComponent = RigidBodyComponent | ColliderComponent | JointComponent;

interface PhysicsWorldConfig {
  gravity: Vector3;
  integrationParameters: {
    dt: number;
    minCcdDt: number;
    erp: number;
    damping: number;
    jointErp: number;
    jointDamping: number;
    allowedLinearError: number;
    allowedAngularError: number;
    maxVelocityIterations: number;
    maxVelocityFrictionIterations: number;
    maxStabilizationIterations: number;
    interleaveRestitutionAndFrictionResolution: boolean;
    minIslandSize: number;
    maxCcdSubsteps: number;
  };
  collisionDetection: {
    predictionDistance: number;
    allowedLinearError: number;
  };
  debugRender: {
    enabled: boolean;
    renderBodies: boolean;
    renderShapes: boolean;
    renderJoints: boolean;
    renderMultibodyJoints: boolean;
    renderContacts: boolean;
    renderCollisionEvents: boolean;
    contactPointLength: number;
    contactNormalLength: number;
  };
}

interface GameObject {
  id: string;
  name: string;
  transform: Transform;
  components: (GameObjectComponent | PhysicsComponent)[];
  children: GameObject[];
  visible: boolean;
  tags: string[];
  layer: number;
}

interface AssetReference {
  id: string;
  type: 'texture' | 'model' | 'audio' | 'script' | 'shader' | 'material';
  path: string;
  name: string;
}

interface EditorConfig {
  appTitle: string;
  shortcuts: Record<string, string>;
  theme: 'light' | 'dark' | 'system';
  autoSave: boolean;
  autoSaveInterval: number;
  gridSize: number;
  snapToGrid: boolean;
  showGrid: boolean;
  showGizmos: boolean;
  cameraSpeed: number;
  viewportBackground: string;
}

interface SceneEditorConfig {
  showHelperGrid: boolean;
  gridSize: number;
  backgroundColor: string;
  renderType: 'solid' | 'wireframe' | 'normals' | 'realistic';
  showLights: boolean;
  showCameras: boolean;
  enableFog: boolean;
  fogColor: string;
  fogNear: number;
  fogFar: number;
}

interface SceneRuntimeConfig {
  backgroundColor: string;
  environment: string;
  shadowsEnabled: boolean;
  shadowType: 'basic' | 'pcf' | 'pcfsoft' | 'vsm';
  antialias: boolean;
  physicallyCorrectLights: boolean;
  toneMapping: 'none' | 'linear' | 'reinhard' | 'cineon' | 'aces';
  exposure: number;
}

interface GameScene {
  id: string;
  name: string;
  objects: GameObject[];
  editorConfig: SceneEditorConfig;
  runtimeConfig: SceneRuntimeConfig;
  physicsWorld: PhysicsWorldConfig;
  assets: AssetReference[];
  activeCamera?: string;
  lightingSetup: any;
  metadata: {
    created: Date;
    modified: Date;
    version: string;
  };
}

interface GameProject {
  name: string;
  path: string;
  lastModified: Date;
  isRunning?: boolean;
  scenes: string[];
  currentScene?: string;
  editorConfig: EditorConfig;
  packageJson: any;
  metadata: {
    created: Date;
    version: string;
    description?: string;
    author?: string;
  };
}

// IPC interface types for Electron
// When adding a new context interface, add it to the exposeContexts() function in preload.ts

interface DevServerInfo {
  port?: number;
  url?: string;
}

interface ThemeModeContext {
  toggle: () => void;
  dark: () => void;
  light: () => void;
  system: () => void;
}

interface ElectronWindow {
  close: () => void;
  minimize: () => void;
  maximize: () => void;
  isMaximized: () => Promise<boolean>;
}

interface ProjectAPI {
  // Project Management
  loadProjects: () => Promise<GameProject[]>;
  createProject: (projectName: string, projectPath?: string) => Promise<GameProject>;
  openProject: (projectPath: string) => Promise<GameProject>;
  saveProject: (project: GameProject) => Promise<void>;
  deleteProject: (projectPath: string) => Promise<void>;
  openProjectFolder: (projectPath: string) => Promise<void>;
  selectProjectDirectory: () => Promise<string | undefined>;
  
  // Scene Management
  loadScene: (projectPath: string, sceneName: string) => Promise<GameScene>;
  saveScene: (projectPath: string, scene: GameScene) => Promise<void>;
  createScene: (projectPath: string, sceneName: string) => Promise<GameScene>;
  deleteScene: (projectPath: string, sceneName: string) => Promise<void>;
  duplicateScene: (projectPath: string, sceneName: string, newName: string) => Promise<GameScene>;
  listScenes: (projectPath: string) => Promise<string[]>;
  
  // Asset Management
  importAsset: (projectPath: string, assetPath: string) => Promise<AssetReference>;
  deleteAsset: (projectPath: string, assetId: string) => Promise<void>;
  getAssets: (projectPath: string) => Promise<AssetReference[]>;
  
  // File System Operations
  readFile: (filePath: string) => Promise<string>;
  writeFile: (filePath: string, content: string) => Promise<void>;
  fileExists: (filePath: string) => Promise<boolean>;
  
  // Legacy - keeping for backward compatibility
  installPackages: (projectName: string) => Promise<void>;
  startDevServer: (projectName: string) => Promise<DevServerInfo>;
  stopDevServer: (projectName: string) => Promise<void>;
  isDevServerRunning: (projectName: string) => Promise<boolean>;
  getServerInfo: (projectName: string) => Promise<DevServerInfo | undefined>;
  connectToEditor: (projectName: string) => Promise<void>;
  sendPropertyUpdate: (projectName: string, property: string, value: unknown, temporary?: boolean) => Promise<void>;
  getSceneInfo: (projectName: string) => Promise<unknown>;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  projectAPI: ProjectAPI;
}
