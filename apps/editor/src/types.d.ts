// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Game Editor Types

interface Vector3 {
  x: number;
  y: number;
  z: number;
}

interface Transform {
  position: Vector3;
  rotation: Vector3;
  scale: Vector3;
}

interface GameObjectComponent {
  id: string;
  type: string;
  enabled: boolean;
  properties: Record<string, any>;
}

// Physics Types for Rapier3D Integration

type RigidBodyType = "dynamic" | "static" | "kinematic";

interface RigidBodyComponent {
  id: string;
  type: "rigidBody";
  enabled: boolean;
  properties: {
    bodyType: RigidBodyType;
    mass?: number;
    linearDamping: number;
    angularDamping: number;
    gravityScale: number;
    canSleep: boolean;
    sleeping: boolean;
    lockTranslations: {
      x: boolean;
      y: boolean;
      z: boolean;
    };
    lockRotations: {
      x: boolean;
      y: boolean;
      z: boolean;
    };
    dominanceGroup: number;
    additionalMassProperties?: {
      mass: number;
      centerOfMass: Vector3;
      principalInertia: Vector3;
      inertiaOrientation: Vector3; // quaternion as Vector3 for simplicity
    };
  };
}

type ColliderShape =
  | { type: "box"; halfExtents: Vector3 }
  | { type: "sphere"; radius: number }
  | { type: "capsule"; halfHeight: number; radius: number }
  | { type: "cylinder"; height: number; radius: number }
  | { type: "cone"; height: number; radius: number }
  | { type: "convexHull"; vertices: Vector3[] }
  | { type: "trimesh"; vertices: Vector3[]; indices: number[] }
  | { type: "heightfield"; heights: number[][]; scale: Vector3 };

interface PhysicsMaterial {
  friction: number;
  restitution: number;
  frictionCombineRule: "average" | "min" | "multiply" | "max";
  restitutionCombineRule: "average" | "min" | "multiply" | "max";
}

interface CollisionGroups {
  membership: number; // Bitmask for which groups this collider belongs to
  filter: number; // Bitmask for which groups this collider can collide with
}

interface ColliderComponent {
  id: string;
  type: "collider";
  enabled: boolean;
  properties: {
    shape: ColliderShape;
    isSensor: boolean;
    density?: number;
    material: PhysicsMaterial;
    collisionGroups: CollisionGroups;
    solverGroups: CollisionGroups;
    activeCollisionTypes: {
      default: boolean;
      kinematic: boolean;
      sensor: boolean;
    };
    activeEvents: {
      collisionEvents: boolean;
      contactForceEvents: boolean;
    };
    contactForceEventThreshold: number;
    massModification: "density" | "mass" | "massProps";
  };
}

type JointType =
  | "fixed"
  | "revolute"
  | "prismatic"
  | "spherical"
  | "rope"
  | "spring"
  | "generic";

interface JointLimits {
  min: number;
  max: number;
}

interface JointMotor {
  targetVel: number;
  targetPos: number;
  stiffness: number;
  damping: number;
  maxForce: number;
}

interface JointComponent {
  id: string;
  type: "joint";
  enabled: boolean;
  properties: {
    jointType: JointType;
    connectedBody: string; // ID of the connected GameObject
    anchor1: Vector3; // Local anchor point on this body
    anchor2: Vector3; // Local anchor point on connected body
    axis1?: Vector3; // Primary axis for revolute/prismatic joints
    axis2?: Vector3; // Secondary axis for some joint types
    limits?: JointLimits;
    motor?: JointMotor;
    breakForce?: number; // Force threshold to break the joint
    breakTorque?: number; // Torque threshold to break the joint
    // Generic joint specific properties
    lockedAxes?: {
      linearX: boolean;
      linearY: boolean;
      linearZ: boolean;
      angularX: boolean;
      angularY: boolean;
      angularZ: boolean;
    };
    motorAxes?: {
      linearX: JointMotor;
      linearY: JointMotor;
      linearZ: JointMotor;
      angularX: JointMotor;
      angularY: JointMotor;
      angularZ: JointMotor;
    };
  };
}

interface ScriptComponent {
  id: string;
  type: "script";
  enabled: boolean;
  properties: {
    scriptPath: string; // relative path to the script file from project root
    autoStart: boolean; // Whether to automatically start the script when the entity is created
    // Parameters that can be passed to the script
    parameters: Record<string, {
      type: "string" | "number" | "boolean" | "vector3" | "gameobject" | "asset";
      value: any;
      description?: string;
    }>;
    // Event handlers that the script can listen to
    eventHandlers: {
      init?: boolean;
      update?: boolean;
      lateUpdate?: boolean;
      fixedUpdate?: boolean;
      destroy?: boolean;
    };
    // Script-specific configuration
    timeScale: number; // Time scale multiplier for this script
    debugMode: boolean; // Enable debug logging for this script
  };
}

type PhysicsComponent =
  | RigidBodyComponent
  | ColliderComponent
  | JointComponent
  | ScriptComponent
  | HeightfieldComponent
  | ExtrudedArcComponent;

// Heightfield Component for Terrain Generation

type HeightfieldGenerationAlgorithm =
  | "perlin"
  | "simplex"
  | "ridged"
  | "fbm" // Fractal Brownian Motion
  | "voronoi"
  | "diamond-square"
  | "random"
  | "flat"
  | "custom"; // for user-provided height data

interface HeightfieldNoiseSettings {
  frequency: number;
  amplitude: number;
  octaves: number;
  persistence: number;
  lacunarity: number;
  // For ridged noise
  ridgeOffset?: number;
  // For voronoi
  voronoiPoints?: number;
  voronoiRandomness?: number;
}

interface HeightfieldLODSettings {
  enabled: boolean;
  levels: number;
  distances: number[]; // Distance thresholds for each LOD level
  simplificationRatio: number[]; // How much to simplify at each level (0-1)
}

interface HeightfieldComponent {
  id: string;
  type: "heightfield";
  enabled: boolean;
  properties: {
    // Dimensions
    width: number; // world units (X axis)
    depth: number; // world units (Z axis)
    rows: number; // number of height samples along depth (Z)
    columns: number; // number of height samples along width (X)

    // Elevation
    minElevation: number;
    maxElevation: number;

    // Generation
    algorithm: HeightfieldGenerationAlgorithm;
    seed: number;

    // Algorithm-specific parameters
    noise: HeightfieldNoiseSettings;

    // For custom heightfields
    customHeights?: number[][];

    // Generated data (computed from parameters)
    heights: number[][]; // [row][column] = elevation value

    // Visual properties
    displacementScale: number; // Multiplier for displacement mapping
    smoothing: boolean; // Apply smoothing filter to generated heights
    wireframe: boolean; // Render as wireframe for debugging

    // LOD settings for performance
    lod: HeightfieldLODSettings;

    // Texture coordinate scaling
    uvScale: Vector2; // How many times to tile textures across the heightfield

    // Auto-regeneration
    autoRegenerate: boolean; // Regenerate when parameters change
    lastGenerated: Date; // Timestamp of last generation

    // Material system (same as mesh components)
    materialRef?: {
      type: "library" | "inline";
      materialId?: string;
      properties?: any;
    };
    textures?: Record<string, string>;
    uniforms?: Record<string, any>;

    // Legacy material support for compatibility
    material?: string;
    materialProps?: Record<string, any>;

    // Rendering properties
    castShadow?: boolean;
    receiveShadow?: boolean;
    renderType?: string;
  };
}

// Extruded Arc Component for Creating Curved Surfaces like Race Tracks

interface ExtrudedArcComponent {
  id: string;
  type: "extrudedArc";
  enabled: boolean;
  properties: {
    // Arc geometry parameters
    arcRadius: number; // Curvature radius
    pitch: number; // Vertical curvature (elevation change per full rotation)
    width: number; // Width of the track/surface
    height: number; // Extrusion height (thickness)
    pathLength: number; // Length along the arc path
    angle: number; // Angular span in radians (0 to 2Ï€ for full circle)
    segments: number; // Number of segments for smoothness
    closed: boolean; // Whether to create a closed loop regardless of angle

    // Cross-section parameters
    crossSectionSegments: number; // Segments across width
    extrusionSegments: number; // Segments along height

    // UV mapping
    uvScale: Vector2; // UV texture coordinate scaling
    flipUVs: boolean; // Flip UV coordinates

    // Auto-regeneration
    autoRegenerate: boolean; // Regenerate when parameters change
    lastGenerated: Date; // Timestamp of last generation

    // Material system (same as mesh components)
    materialRef?: {
      type: "library" | "inline";
      materialId?: string;
      properties?: any;
    };
    textures?: Record<string, string>;
    uniforms?: Record<string, any>;

    // Legacy material support for compatibility
    material?: string;
    materialProps?: Record<string, any>;

    // Rendering properties
    castShadow?: boolean;
    receiveShadow?: boolean;
    renderType?: string;
  };
}

interface PhysicsWorldConfig {
  gravity: Vector3;
  integrationParameters: {
    dt: number;
    minCcdDt: number;
    erp: number;
    damping: number;
    jointErp: number;
    jointDamping: number;
    allowedLinearError: number;
    allowedAngularError: number;
    maxVelocityIterations: number;
    maxVelocityFrictionIterations: number;
    maxStabilizationIterations: number;
    interleaveRestitutionAndFrictionResolution: boolean;
    minIslandSize: number;
    maxCcdSubsteps: number;
  };
  collisionDetection: {
    predictionDistance: number;
    allowedLinearError: number;
  };
  debugRender: {
    enabled: boolean;
    renderBodies: boolean;
    renderShapes: boolean;
    renderJoints: boolean;
    renderMultibodyJoints: boolean;
    renderContacts: boolean;
    renderCollisionEvents: boolean;
    contactPointLength: number;
    contactNormalLength: number;
  };
}

interface GameObject {
  id: string;
  name: string;
  transform: Transform;
  components: (GameObjectComponent | PhysicsComponent)[];
  children: GameObject[];
  visible: boolean;
  tags: string[];
  layer: number;
}

interface AssetReference {
  id: string;
  type: "texture" | "model" | "audio" | "script" | "shader" | "material";
  path: string;
  name: string;
}

interface EditorConfig {
  appTitle: string;
  shortcuts: Record<string, string>;
  theme: "light" | "dark" | "system";
  autoSave: boolean;
  autoSaveInterval: number;
  gridSize: number;
  snapToGrid: boolean;
  showGrid: boolean;
  showGizmos: boolean;
  cameraSpeed: number;
  viewportBackground: string;
}

interface SceneEditorConfig {
  showHelperGrid: boolean;
  gridSize: number;
  backgroundColor: string;
  renderType: "solid" | "wireframe" | "normals" | "realistic";
  showLights: boolean;
  showCameras: boolean;
  enableFog: boolean;
  fogColor: string;
  fogNear: number;
  fogFar: number;
}

interface SceneRuntimeConfig {
  backgroundColor: string;
  environment: string;
  shadowsEnabled: boolean;
  shadowType: "basic" | "pcf" | "pcfsoft" | "vsm";
  antialias: boolean;
  physicallyCorrectLights: boolean;
  toneMapping: "none" | "linear" | "reinhard" | "cineon" | "aces";
  exposure: number;
}

interface GameScene {
  id: string;
  name: string;
  objects: GameObject[];
  materials: MaterialDefinition[];
  editorConfig: SceneEditorConfig;
  runtimeConfig: SceneRuntimeConfig;
  physicsWorld: PhysicsWorldConfig;
  assets: AssetReference[];
  activeCamera?: string;
  lightingSetup: any;
  metadata: {
    created: Date;
    modified: Date;
    version: string;
  };
}

interface GameProject {
  name: string;
  path: string;
  lastModified: Date;
  isRunning?: boolean;
  scenes: string[];
  currentScene?: string;
  editorConfig: EditorConfig;
  packageJson: any;
  metadata: {
    created: Date;
    version: string;
    description?: string;
    author?: string;
  };
}

// IPC interface types for Electron
// When adding a new context interface, add it to the exposeContexts() function in preload.ts

interface DevServerInfo {
  port?: number;
  url?: string;
}

interface ConfigAPI {
  readConfigFile: (filePath: string) => Promise<any>;
  writeConfigFile: (filePath: string, content: any) => Promise<boolean>;
  installPackages: (
    projectPath: string,
    packageManager: string,
    packages?: string[],
  ) => Promise<{ success: boolean; output: string }>;
  getPackageInfo: (
    projectPath: string,
  ) => Promise<{ hasPackageJson: boolean; suggestedPackageManager: string }>;
}

interface ScriptAPI {
  startWatching: (projectPath: string) => Promise<boolean>;
  stopWatching: (projectPath: string) => Promise<boolean>;
  compileScript: (projectPath: string, scriptPath: string) => Promise<{ success: boolean; outputPath?: string; error?: string }>;
  getCompiledScripts: (projectPath: string) => Promise<Record<string, string>>;
  getCompilationStatus: (projectPath: string) => Promise<{ isWatching: boolean; compiledCount: number; lastCompilation?: Date }>;
  getImportMap: (projectPath: string) => Promise<Record<string, any> | null>;
}

interface ThemeModeContext {
  toggle: () => void;
  dark: () => void;
  light: () => void;
  system: () => void;
}

interface ElectronWindow {
  close: () => void;
  minimize: () => void;
  maximize: () => void;
  isMaximized: () => Promise<boolean>;
}

interface ProjectAPI {
  // Project Management
  loadProjects: () => Promise<GameProject[]>;
  createProject: (
    projectName: string,
    projectPath?: string,
  ) => Promise<GameProject>;
  openProject: (projectPath: string) => Promise<GameProject>;
  saveProject: (project: GameProject) => Promise<void>;
  deleteProject: (projectPath: string) => Promise<void>;
  openProjectFolder: (projectPath: string) => Promise<void>;
  selectProjectDirectory: () => Promise<string | undefined>;

  // Scene Management
  loadScene: (projectPath: string, sceneName: string) => Promise<GameScene>;
  saveScene: (projectPath: string, scene: GameScene) => Promise<void>;
  createScene: (projectPath: string, sceneName: string) => Promise<GameScene>;
  deleteScene: (projectPath: string, sceneName: string) => Promise<void>;
  duplicateScene: (
    projectPath: string,
    sceneName: string,
    newName: string,
  ) => Promise<GameScene>;
  listScenes: (projectPath: string) => Promise<string[]>;

  // Asset Management
  selectAssetFiles: () => Promise<string[]>;
  importAssetFromData: (
    projectPath: string,
    fileName: string,
    fileData: ArrayBuffer,
  ) => Promise<AssetReference>;
  importAsset: (
    projectPath: string,
    assetPath: string,
  ) => Promise<AssetReference>;
  deleteAsset: (projectPath: string, assetId: string) => Promise<void>;
  getAssets: (projectPath: string) => Promise<AssetReference[]>;
  getAssetDataUrl: (
    projectPath: string,
    assetPath: string,
  ) => Promise<string | null>;
  getAssetUrl: (
    projectPath: string,
    assetPath: string,
  ) => Promise<string | null>;
  getAssetServerPort: (projectPath: string) => Promise<number>;

  // File System Operations
  readFile: (filePath: string) => Promise<string>;
  writeFile: (filePath: string, content: string) => Promise<void>;
  fileExists: (filePath: string) => Promise<boolean>;

  // Legacy - keeping for backward compatibility
  installPackages: (projectName: string) => Promise<void>;
  startDevServer: (projectName: string) => Promise<DevServerInfo>;
  stopDevServer: (projectName: string) => Promise<void>;
  isDevServerRunning: (projectName: string) => Promise<boolean>;
  getServerInfo: (projectName: string) => Promise<DevServerInfo | undefined>;
  connectToEditor: (projectName: string) => Promise<void>;
  sendPropertyUpdate: (
    projectName: string,
    property: string,
    value: unknown,
    temporary?: boolean,
  ) => Promise<void>;
  getSceneInfo: (projectName: string) => Promise<unknown>;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  projectAPI: ProjectAPI;
  configAPI: ConfigAPI;
  scriptAPI: ScriptAPI;
}

// Enhanced Material System with TSL Support

type TextureType =
  | "color"
  | "normal"
  | "roughness"
  | "metalness"
  | "emissive"
  | "ao"
  | "displacement"
  | "alpha"
  | "environment"
  | "lightmap"
  | "bumpmap"
  | "clearcoat"
  | "clearcoat-normal"
  | "clearcoat-roughness"
  | "iridescence"
  | "iridescence-thickness"
  | "sheen"
  | "specular-intensity"
  | "specular-color"
  | "transmission"
  | "thickness";

interface TextureReference {
  id: string;
  assetId: string; // Reference to AssetReference
  type: TextureType;
  wrapS?: "repeat" | "clampToEdge" | "mirroredRepeat";
  wrapT?: "repeat" | "clampToEdge" | "mirroredRepeat";
  repeat: Vector2;
  offset: Vector2;
  rotation: number;
  flipY: boolean;
  generateMipmaps: boolean;
  minFilter?:
    | "nearest"
    | "linear"
    | "nearestMipmapNearest"
    | "nearestMipmapLinear"
    | "linearMipmapNearest"
    | "linearMipmapLinear";
  magFilter?: "nearest" | "linear";
  anisotropy: number;
}

interface Vector2 {
  x: number;
  y: number;
}

// TSL Node System Types

type TSLNodeType =
  // Input nodes
  | "uniform"
  | "attribute"
  | "varying"
  | "texture"
  | "cubeTexture"
  | "time"
  | "deltaTime"
  | "frameId"
  // Math nodes
  | "add"
  | "subtract"
  | "multiply"
  | "divide"
  | "power"
  | "sqrt"
  | "sin"
  | "cos"
  | "tan"
  | "atan2"
  | "abs"
  | "floor"
  | "ceil"
  | "round"
  | "min"
  | "max"
  | "clamp"
  | "saturate"
  | "smoothstep"
  | "step"
  | "mix"
  | "dot"
  | "cross"
  | "normalize"
  | "length"
  | "distance"
  | "reflect"
  | "refract"
  | "faceforward"
  // UV and coordinate nodes
  | "uv"
  | "screenUV"
  | "worldUV"
  | "matcap"
  | "parallax"
  | "rotate"
  | "scale"
  | "translate"
  // Lighting nodes
  | "lambert"
  | "phong"
  | "physical"
  | "toon"
  | "fresnel"
  | "rim"
  // Utility nodes
  | "split"
  | "join"
  | "swizzle"
  | "convert"
  | "if"
  | "switch"
  | "loop"
  // Noise and patterns
  | "noise"
  | "fbm"
  | "voronoi"
  | "checker"
  | "gradient"
  | "stripes"
  // Color nodes
  | "colorSpace"
  | "hue"
  | "saturation"
  | "brightness"
  | "contrast"
  | "levels"
  // Output nodes
  | "output"
  | "materialOutput";

type TSLDataType =
  | "float"
  | "vec2"
  | "vec3"
  | "vec4"
  | "mat3"
  | "mat4"
  | "sampler2D"
  | "samplerCube"
  | "bool"
  | "int";

interface TSLNodeInput {
  id: string;
  name: string;
  type: TSLDataType;
  required: boolean;
  defaultValue?: any;
  min?: number;
  max?: number;
  options?: string[]; // For enum-like inputs
}

interface TSLNodeOutput {
  id: string;
  name: string;
  type: TSLDataType;
}

interface TSLNodeConnection {
  from: {
    nodeId: string;
    outputId: string;
  };
  to: {
    nodeId: string;
    inputId: string;
  };
}

interface TSLGraphNode {
  id: string;
  type: TSLNodeType;
  name: string;
  position: Vector2;
  inputs: TSLNodeInput[];
  outputs: TSLNodeOutput[];
  properties: Record<string, any>;
  // For uniform nodes
  uniformValue?: any;
  uniformType?: TSLDataType;
  // For texture nodes
  textureReference?: string; // Reference to TextureReference id
  // For attribute nodes
  attributeName?: string;
}

interface TSLShaderGraph {
  id: string;
  name: string;
  description: string;
  nodes: TSLGraphNode[];
  connections: TSLNodeConnection[];
  // Define which outputs connect to material properties
  materialConnections: {
    colorNode?: string; // nodeId.outputId
    normalNode?: string;
    roughnessNode?: string;
    metalnessNode?: string;
    emissiveNode?: string;
    alphaNode?: string;
    displacementNode?: string;
    clearcoatNode?: string;
    clearcoatRoughnessNode?: string;
    clearcoatNormalNode?: string;
    sheenNode?: string;
    iridescenceNode?: string;
    iridescenceIORNode?: string;
    iridescenceThicknessNode?: string;
    specularIntensityNode?: string;
    specularColorNode?: string;
    iorNode?: string;
    transmissionNode?: string;
    thicknessNode?: string;
    attenuationDistanceNode?: string;
    attenuationColorNode?: string;
    dispersionNode?: string;
    anisotropyNode?: string;
  };
  metadata: {
    created: Date;
    modified: Date;
    version: string;
    author?: string;
    tags: string[];
  };
}

// Material Type Definitions

type MaterialType =
  | "basic"
  | "lambert"
  | "phong"
  | "standard"
  | "physical"
  | "toon"
  | "shader"
  | "points"
  | "line"
  | "lineBasic"
  | "lineDashed"
  | "sprite"
  | "shadow";

// Base material properties that all materials share
interface BaseMaterialProperties {
  name?: string;
  transparent: boolean;
  opacity: number;
  alphaTest: number;
  side: 0 | 1 | 2; // FrontSide | BackSide | DoubleSide
  visible: boolean;
  depthTest: boolean;
  depthWrite: boolean;
  blending: "normal" | "additive" | "subtractive" | "multiply" | "custom";
  premultipliedAlpha: boolean;
  dithering: boolean;
  fog: boolean;
  wireframe: boolean;
  vertexColors: boolean;
  clippingPlanes?: any[];
  clipIntersection: boolean;
  clipShadows: boolean;
  colorWrite: boolean;
  precision?: "lowp" | "mediump" | "highp";
  polygonOffset: boolean;
  polygonOffsetFactor: number;
  polygonOffsetUnits: number;
  alphaHash: boolean;
  stencilWrite: boolean;
  stencilFunc: number;
  stencilRef: number;
  stencilFuncMask: number;
  stencilFail: number;
  stencilZFail: number;
  stencilZPass: number;
  stencilWriteMask: number;
}

interface BasicMaterialProperties extends BaseMaterialProperties {
  type: "basic";
  color: string;
  map?: string; // TextureReference id
  lightMap?: string;
  lightMapIntensity: number;
  aoMap?: string;
  aoMapIntensity: number;
  specularMap?: string;
  alphaMap?: string;
  envMap?: string;
  combine: "multiply" | "mix" | "add";
  reflectivity: number;
  refractionRatio: number;
}

interface LambertMaterialProperties extends BaseMaterialProperties {
  type: "lambert";
  color: string;
  emissive: string;
  emissiveIntensity: number;
  emissiveMap?: string;
  map?: string;
  lightMap?: string;
  lightMapIntensity: number;
  aoMap?: string;
  aoMapIntensity: number;
  specularMap?: string;
  alphaMap?: string;
  envMap?: string;
  combine: "multiply" | "mix" | "add";
  reflectivity: number;
  refractionRatio: number;
}

interface PhongMaterialProperties extends BaseMaterialProperties {
  type: "phong";
  color: string;
  emissive: string;
  emissiveIntensity: number;
  emissiveMap?: string;
  specular: string;
  shininess: number;
  map?: string;
  lightMap?: string;
  lightMapIntensity: number;
  aoMap?: string;
  aoMapIntensity: number;
  bumpMap?: string;
  bumpScale: number;
  normalMap?: string;
  normalMapType: "tangentSpace" | "objectSpace";
  normalScale: Vector2;
  displacementMap?: string;
  displacementScale: number;
  displacementBias: number;
  specularMap?: string;
  alphaMap?: string;
  envMap?: string;
  combine: "multiply" | "mix" | "add";
  reflectivity: number;
  refractionRatio: number;
}

interface StandardMaterialProperties extends BaseMaterialProperties {
  type: "standard";
  color: string;
  emissive: string;
  emissiveIntensity: number;
  emissiveMap?: string;
  roughness: number;
  metalness: number;
  map?: string;
  lightMap?: string;
  lightMapIntensity: number;
  aoMap?: string;
  aoMapIntensity: number;
  bumpMap?: string;
  bumpScale: number;
  normalMap?: string;
  normalMapType: "tangentSpace" | "objectSpace";
  normalScale: Vector2;
  displacementMap?: string;
  displacementScale: number;
  displacementBias: number;
  roughnessMap?: string;
  metalnessMap?: string;
  alphaMap?: string;
  envMap?: string;
  envMapIntensity: number;
}

interface PhysicalMaterialProperties extends BaseMaterialProperties {
  type: "physical";
  // Standard material properties
  color: string;
  emissive: string;
  emissiveIntensity: number;
  emissiveMap?: string;
  roughness: number;
  metalness: number;
  map?: string;
  lightMap?: string;
  lightMapIntensity: number;
  aoMap?: string;
  aoMapIntensity: number;
  bumpMap?: string;
  bumpScale: number;
  normalMap?: string;
  normalMapType: "tangentSpace" | "objectSpace";
  normalScale: Vector2;
  displacementMap?: string;
  displacementScale: number;
  displacementBias: number;
  roughnessMap?: string;
  metalnessMap?: string;
  alphaMap?: string;
  envMap?: string;
  envMapIntensity: number;
  // Physical material specific properties
  clearcoat: number;
  clearcoatMap?: string;
  clearcoatRoughness: number;
  clearcoatRoughnessMap?: string;
  clearcoatNormalScale: Vector2;
  clearcoatNormalMap?: string;
  ior: number;
  reflectivity: number;
  iridescence: number;
  iridescenceMap?: string;
  iridescenceIOR: number;
  iridescenceThicknessRange: Vector2;
  iridescenceThicknessMap?: string;
  sheen: number;
  sheenColor: string;
  sheenColorMap?: string;
  sheenRoughness: number;
  sheenRoughnessMap?: string;
  transmission: number;
  transmissionMap?: string;
  thickness: number;
  thicknessMap?: string;
  attenuationDistance: number;
  attenuationColor: string;
  specularIntensity: number;
  specularIntensityMap?: string;
  specularColor: string;
  specularColorMap?: string;
  anisotropy: number;
  anisotropyRotation: number;
  anisotropyMap?: string;
}

interface ToonMaterialProperties extends BaseMaterialProperties {
  type: "toon";
  color: string;
  emissive: string;
  emissiveIntensity: number;
  emissiveMap?: string;
  map?: string;
  bumpMap?: string;
  bumpScale: number;
  normalMap?: string;
  normalMapType: "tangentSpace" | "objectSpace";
  normalScale: Vector2;
  displacementMap?: string;
  displacementScale: number;
  displacementBias: number;
  gradientMap?: string;
  alphaMap?: string;
}

interface ShaderMaterialProperties extends BaseMaterialProperties {
  type: "shader";
  // TSL Shader Graph
  shaderGraph?: string; // TSLShaderGraph id
  // Traditional uniforms for fallback
  uniforms: Record<
    string,
    {
      type: TSLDataType;
      value: any;
    }
  >;
  vertexShader?: string; // GLSL fallback
  fragmentShader?: string; // GLSL fallback
  // Lighting model for shader materials
  lights: boolean;
  clipping: boolean;
  extensions: {
    derivatives: boolean;
    fragDepth: boolean;
    drawBuffers: boolean;
    shaderTextureLOD: boolean;
  };
}

type MaterialProperties =
  | BasicMaterialProperties
  | LambertMaterialProperties
  | PhongMaterialProperties
  | StandardMaterialProperties
  | PhysicalMaterialProperties
  | ToonMaterialProperties
  | ShaderMaterialProperties;

// Centralized Material Definition
interface MaterialDefinition {
  id: string;
  name: string;
  description: string;
  properties: MaterialProperties;
  textures: TextureReference[];
  shaderGraphs: TSLShaderGraph[];
  previewSettings: {
    geometry: "sphere" | "cube" | "plane" | "cylinder";
    lighting: "studio" | "outdoor" | "indoor" | "custom";
    environment?: string; // HDRI environment map
  };
  metadata: {
    created: Date;
    modified: Date;
    version: string;
    author?: string;
    tags: string[];
    category: string;
  };
}

// Material Library/Registry
interface MaterialLibrary {
  id: string;
  name: string;
  description: string;
  materials: MaterialDefinition[];
  sharedTextures: TextureReference[];
  sharedShaderGraphs: TSLShaderGraph[];
  metadata: {
    created: Date;
    modified: Date;
    version: string;
    author?: string;
  };
}

// Enhanced AssetReference to support more texture types
interface EnhancedAssetReference extends AssetReference {
  // For texture assets
  textureProperties?: {
    format: "RGB" | "RGBA" | "RGBE" | "RGBM" | "sRGB" | "Linear";
    type: "UnsignedByte" | "Float" | "HalfFloat";
    colorSpace: "sRGB" | "Linear" | "Rec2020" | "DisplayP3";
    flipY: boolean;
    generateMipmaps: boolean;
    premultiplyAlpha: boolean;
    unpackAlignment: number;
  };
  // For model assets
  modelProperties?: {
    format: "GLTF" | "GLB" | "FBX" | "OBJ" | "DAE" | "PLY" | "STL";
    animations: string[];
    materials: string[];
    textures: string[];
  };
}
